project(nanoem)
cmake_minimum_required(VERSION 3.5)

set_property(GLOBAL PROPERTY USE_FOLDERS ON)
set(CMAKE_C_STANDARD 99)
set(CMAKE_MODULE_PATH ${CMAKE_CURRENT_SOURCE_DIR}/cmake)
set(CMAKE_MACOSX_RPATH ON)
set(CMAKE_POSITION_INDEPENDENT_CODE ON)
set(CMAKE_XCODE_ATTRIBUTE_DEBUG_INFORMATION_FORMAT[variant=MinSizeRel] "dwarf-with-dsym")
set(CMAKE_XCODE_ATTRIBUTE_GCC_GENERATE_DEBUGGING_SYMBOLS[variant=MinSizeRel] "YES")
set(CMAKE_XCODE_ATTRIBUTE_DEPLOYMENT_POSTPROCESSING[variant=MinSizeRel] "YES")
if(WIN32 AND "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
  set(CMAKE_CXX_STANDARD 17)
endif()

option(NANOEM_ENABLE_ASAN "Enable clang/gcc ASan (address sanitizer) option." OFF)
option(NANOEM_ENABLE_BLENDOP_MINMAX "Enable building sokol with min/max blendop support" ON)
option(NANOEM_ENABLE_COVERAGE "Enable code coverage option." OFF)
option(NANOEM_ENABLE_DEBUG_ALLOCATOR "Enable building debug memory allocator" OFF)
option(NANOEM_ENABLE_DEBUG_LABEL "Enable building nanoem with debug labels." OFF)
option(NANOEM_ENABLE_GLFW "Enable GLFW based application option." OFF)
option(NANOEM_ENABLE_IMGUI_INDEX32 "Enable building ImGui with 32bit indices support" ON)
option(NANOEM_ENABLE_IMGUI_FILE_DIALOG "Enable building ImGuiFileDialog (https://github.com/aiekick/ImGuiFileDialog) option" OFF)
option(NANOEM_ENABLE_LOGGING "Enable logging with spdlog." OFF)
option(NANOEM_ENABLE_LTO "Enable Link Time Optimization when clang is used." OFF)
option(NANOEM_ENABLE_MIMALLOC "Enable mimalloc as allocator" OFF)
option(NANOEM_ENABLE_MSAN "Enable clang/gcc MSan (memory sanitizer) option." OFF)
option(NANOEM_ENABLE_NANOMSG "Enable nanomsg" ON)
option(NANOEM_ENABLE_OPTICK "Enable optick profiler" OFF)
option(NANOEM_ENABLE_PEDANTIC_WARNINGS "Enable pedantic warning option." OFF)
option(NANOEM_ENABLE_QT "Enable building Qt application" OFF)
option(NANOEM_ENABLE_SDEF "Enable building nanoem with SDEF deformation." ON)
option(NANOEM_ENABLE_SENTRY_SDK "Enable Sentry SDK" OFF)
option(NANOEM_ENABLE_SHADER_OPTIMIZED "Enable building nanoem with shader optimization." ON)
option(NANOEM_ENABLE_SOFTBODY "Enable building nanoem with softbody." OFF)
option(NANOEM_ENABLE_STATIC_BUNDLE_PLUGIN "Enable all plugins as one bundled static plugin" OFF)
option(NANOEM_ENABLE_TBB "Enable building nanoem with Threading Building Blocks." ON)
option(NANOEM_ENABLE_TEST "Enable building unit test option." OFF)
option(NANOEM_ENABLE_TSAN "Enable clang/gcc TSan (thread sanitizer) option." OFF)
option(NANOEM_ENABLE_UBSAN "Enable clang/gcc UBSan (undefined behavior sanitizer) option." OFF)
option(NANOEM_ENABLE_UPDATE_CREDITS "Enable updating credits per cmake execution." OFF)
option(NANOEM_ENABLE_PLUGIN_WASM "Enable bundling release build of plugin_wasm" OFF)
option(NANOEM_ENABLE_PROTOC "Enable building protocol buffer source code generation with protoc-c" OFF)
option(NANOEM_MINIMAL "Builds nanoem library only." OFF)
option(SOKOL_ENABLE_DEBUG "Enable building sokol with debug validation layer." OFF)

mark_as_advanced(NANOEM_ENABLE_SHADER_OPTIMIZED NANOEM_ENABLE_SDEF NANOEM_ENABLE_SOFTBODY SOKOL_ENABLE_UPDATE_CREDITS NANOEM_ENABLE_OPTICK NANOEM_ENABLE_PROTOC)
define_property(GLOBAL PROPERTY NANOEM_PROPERTY_INSTALL_PLUGINS BRIEF_DOCS "all installing plugins for nanoem binary bundle" FULL_DOCS "all installing plugins for nanoem binary bundle")

cmake_policy(SET CMP0028 NEW)
if(CMAKE_VERSION VERSION_GREATER "2.8.11")
  cmake_policy(SET CMP0022 NEW)
endif()
if(NANOEM_ENABLE_LTO AND CMAKE_VERSION VERSION_GREATER "3.9")
  cmake_policy(SET CMP0069 NEW)
  include(CheckIPOSupported)
  check_ipo_supported()
endif()

# architecture and compiler selection
if(APPLE)
  set(NANOEM_TARGET_ARCHITECTURE "ub" CACHE STRING "Target architecture to build nanoem")
elseif("${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "arm64" OR "${CMAKE_SYSTEM_PROCESSOR}" STREQUAL "aarch64")
  set(NANOEM_TARGET_ARCHITECTURE "arm64" CACHE STRING "Target architecture to build nanoem")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 8)
  set(NANOEM_TARGET_ARCHITECTURE "x86_64" CACHE STRING "Target architecture to build nanoem")
elseif(CMAKE_SIZEOF_VOID_P EQUAL 4)
  set(NANOEM_TARGET_ARCHITECTURE "i386" CACHE STRING "Target architecture to build nanoem")
endif()
set_property(CACHE NANOEM_TARGET_ARCHITECTURE PROPERTY STRINGS "x86_64;i386;arm64;arm32;ub")
if(MSVC)
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    set(NANOEM_TARGET_COMPILER "clang" CACHE STRING "Target architecture to build nanoem")
  elseif(${MSVC_VERSION} GREATER_EQUAL 1930)
    set(NANOEM_TARGET_COMPILER "vs2022" CACHE STRING "Target architecture to build nanoem")
  elseif(${MSVC_VERSION} GREATER_EQUAL 1920)
    set(NANOEM_TARGET_COMPILER "vs2019" CACHE STRING "Target architecture to build nanoem")
  elseif(${MSVC_VERSION} GREATER_EQUAL 1910)
    set(NANOEM_TARGET_COMPILER "vs2017" CACHE STRING "Target architecture to build nanoem")
  elseif(${MSVC_VERSION} GREATER_EQUAL 1900)
    set(NANOEM_TARGET_COMPILER "vs2015" CACHE STRING "Target architecture to build nanoem")
  elseif(${MSVC_VERSION} GREATER_EQUAL 1800)
    set(NANOEM_TARGET_COMPILER "vs2013" CACHE STRING "Target architecture to build nanoem")
  endif()
  set_property(CACHE NANOEM_TARGET_COMPILER PROPERTY STRINGS "clang;vs2022;vs2019;vs2017;vs2015;vs2013")
else()
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    set(NANOEM_TARGET_COMPILER "clang" CACHE STRING "Target architecture to build nanoem")
  else()
    set(NANOEM_TARGET_COMPILER "gcc" CACHE STRING "Target architecture to build nanoem")
  endif()
  set_property(CACHE NANOEM_TARGET_COMPILER PROPERTY STRINGS "clang;gcc")
endif()
message(STATUS "[global] target architecture is ${NANOEM_TARGET_ARCHITECTURE} and compiler is ${NANOEM_TARGET_COMPILER}")

function(nanoem_cmake_get_install_path _name _base_path _debug_path _release_path)
  if(DEFINED ENV{NANOEM_BUILD_DEPENDENCIES_DIRECTORY})
    set(base_path $ENV{NANOEM_BUILD_DEPENDENCIES_DIRECTORY}/${_name})
  else()
    set(base_path ${PROJECT_SOURCE_DIR}/dependencies/${_name})
  endif()
  get_filename_component(base_path ${base_path} ABSOLUTE)
  if(DEFINED ENV{NANOEM_TARGET_SYSTEM_NAME})
    set(_system_name $ENV{NANOEM_TARGET_SYSTEM_NAME})
  else()
    string(TOLOWER ${CMAKE_SYSTEM_NAME} _system_name)
  endif()
  if(DEFINED ENV{NANOEM_TARGET_COMPILER})
    set(_target_compiler $ENV{NANOEM_TARGET_COMPILER})
  else()
    set(_target_compiler ${NANOEM_TARGET_COMPILER})
  endif()
  if(DEFINED ENV{NANOEM_TARGET_ARCHITECTURES})
    set(_arch $ENV{NANOEM_TARGET_ARCHITECTURES})
  elseif(DEFINED ENV{NANOEM_TARGET_ARCHITECTURE})
    set(_arch $ENV{NANOEM_TARGET_ARCHITECTURE})
  else()
    set(_arch ${NANOEM_TARGET_ARCHITECTURE})
  endif()
  set(${_base_path} ${base_path} PARENT_SCOPE)
  set(common_prefix_path ${base_path}/out/${_system_name}/${_target_compiler}/${_arch})
  set(${_debug_path} ${common_prefix_path}/debug/install-root PARENT_SCOPE)
  set(${_release_path} ${common_prefix_path}/release/install-root PARENT_SCOPE)
endfunction()

function(nanoem_cmake_bootstrap _project_name_prefix _build_type)
  if(MSVC)
    if(BUILD_SHARED_LIBS)
      set(building_library_flag_src "/MT")
      set(building_library_flag_dst "/MD")
    else()
      set(building_library_flag_src "/MD")
      set(building_library_flag_dst "/MT")
    endif()
    foreach(type debug release relwithdebinfo minsizerel)
      string(TOUPPER ${type} type_toupper)
      set(nanoem_cflags_${type} "${CMAKE_C_FLAGS_${type_toupper}}")
      set(nanoem_cxxflags_${type} "${CMAKE_CXX_FLAGS_${type_toupper}}")
    endforeach()
    foreach(type debug)
      set(nanoem_cflags_${type} "${nanoem_cflags_${type}} /MP")
      set(nanoem_cxxflags_${type} "${nanoem_cxxflags_${type}} /EHsc /MP")
      string(REPLACE "${building_library_flag_src}d" "${building_library_flag_dst}d" nanoem_cflags_${type} "${nanoem_cflags_${type}}")
      string(REPLACE "${building_library_flag_src}d" "${building_library_flag_dst}d" nanoem_cxxflags_${type} "${nanoem_cxxflags_${type}}")
    endforeach()
    foreach(type release relwithdebinfo minsizerel)
      set(nanoem_cflags_${type} "${nanoem_cflags_${type}} /MP")
      set(nanoem_cxxflags_${type} "${nanoem_cxxflags_${type}} /EHsc /MP")
      string(REPLACE "${building_library_flag_src}" "${building_library_flag_dst}" nanoem_cflags_${type} "${nanoem_cflags_${type}}")
      string(REPLACE "${building_library_flag_src}" "${building_library_flag_dst}" nanoem_cxxflags_${type} "${nanoem_cxxflags_${type}}")
    endforeach()
    if(NANOEM_ENABLE_SENTRY_SDK)
      foreach(type release minsizerel)
        #string(TOUPPER ${type} type_toupper)
        set(nanoem_cflags_${type} "${nanoem_cflags_${type}} /Zi")
        set(nanoem_cxxflags_${type} "${nanoem_cxxflags_${type}} /Zi")
      endforeach()
    endif()
    foreach(type debug release relwithdebinfo minsizerel)
      string(TOUPPER ${type} type_toupper)
      set(_cflags "${CMAKE_C_FLAGS_${type_toupper}} ${nanoem_cflags_${type}} -utf-8")
      set(_cxxflags "${CMAKE_CXX_FLAGS_${type_toupper}} ${nanoem_cxxflags_${type}} -utf-8")
      set(CMAKE_C_FLAGS_${type_toupper} ${_cflags} PARENT_SCOPE)
      set(CMAKE_CXX_FLAGS_${type_toupper} ${_cxxflags} PARENT_SCOPE)
    endforeach()
  elseif(WIN32 AND "${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    foreach(type debug release relwithdebinfo minsizerel)
      string(TOUPPER ${type} type_toupper)
      set(_cflags "${CMAKE_C_FLAGS_${type_toupper}}")
      set(_cxxflags "${CMAKE_CXX_FLAGS_${type_toupper}}")
      string(REPLACE "-D_DLL" "" _cflags "${_cflags}")
      string(REPLACE "-D_DLL" "" _cxxflags "${_cxxflags}")
      set(CMAKE_C_FLAGS_${type_toupper} ${_cflags} PARENT_SCOPE)
      set(CMAKE_CXX_FLAGS_${type_toupper} ${_cxxflags} PARENT_SCOPE)
    endforeach()
  elseif(NANOEM_ENABLE_SENTRY_SDK AND ("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang" OR CMAKE_COMPILER_IS_GNUCXX))
    set(nanoem_cflags "${nanoem_cflags} -g")
    set(nanoem_cxxflags "${nanoem_cxxflags} -g")
  endif()
  string(TOUPPER nanoem PROJECT_NAME_PREFIX)
  set(${_project_name_prefix} NANOEM PARENT_SCOPE)
  if(NANOEM_ENABLE_ASAN)
    if(MSVC)
      set(CMAKE_C_FLAGS_ASAN "/fsanitize=address" CACHE STRING "Flags used by the C compiler during ASan builds." FORCE)
      set(CMAKE_CXX_FLAGS_ASAN "/fsanitize=address" CACHE STRING "Flags used by the C++ compiler during ASan builds." FORCE)
      mark_as_advanced(CMAKE_C_FLAGS_ASAN CMAKE_CXX_FLAGS_ASAN)
    else()
      find_package(ASan)
    endif()
    set(nanoem_cflags "${nanoem_cflags} ${CMAKE_C_FLAGS_ASAN}")
    set(nanoem_cxxflags "${nanoem_cxxflags} ${CMAKE_CXX_FLAGS_ASAN}")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} ${CMAKE_EXE_LINKER_FLAGS_ASAN}")
    set(nanoem_shared_linker_flags "${nanoem_shared_linker_flags} ${CMAKE_SHARED_LINKER_FLAGS_ASAN}")
  elseif(NANOEM_ENABLE_MSAN)
    find_package(MSan)
    configure_file(${PROJECT_SOURCE_DIR}/cmake/msan-blacklist.in ${PROJECT_BINARY_DIR}/msan-blacklist)
    set(msan_blacklist "-fsanitize-blacklist=${PROJECT_BINARY_DIR}/msan-blacklist")
    set(nanoem_cflags "${nanoem_cflags} ${CMAKE_C_FLAGS_MSAN} ${msan_blacklist}")
    set(nanoem_cxxflags "${nanoem_cxxflags} ${CMAKE_CXX_FLAGS_MSAN} ${msan_blacklist}")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} ${CMAKE_EXE_LINKER_FLAGS_MSAN}")
    set(nanoem_shared_linker_flags "${nanoem_shared_linker_flags} ${CMAKE_SHARED_LINKER_FLAGS_MSAN}")
  elseif(NANOEM_ENABLE_TSAN)
    find_package(TSan)
    set(nanoem_cflags "${nanoem_cflags} ${CMAKE_C_FLAGS_TSAN}")
    set(nanoem_cxxflags "${nanoem_cxxflags} ${CMAKE_CXX_FLAGS_TSAN}")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} ${CMAKE_EXE_LINKER_FLAGS_MTAN}")
    set(nanoem_shared_linker_flags "${nanoem_shared_linker_flags} ${CMAKE_SHARED_LINKER_FLAGS_TSAN}")
  elseif(NANOEM_ENABLE_UBSAN)
    find_package(UBSan)
    set(nanoem_cflags "${nanoem_cflags} ${CMAKE_C_FLAGS_UBSAN}")
    set(nanoem_cxxflags "${nanoem_cxxflags} ${CMAKE_CXX_FLAGS_UBSAN}")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} ${CMAKE_EXE_LINKER_FLAGS_UBSAN}")
    set(nanoem_shared_linker_flags "${nanoem_shared_linker_flags} ${CMAKE_SHARED_LINKER_FLAGS_UBSAN}")
  else()
    set(nanoem_cflags "${nanoem_cflags} ${CMAKE_C_FLAGS}")
    set(nanoem_cxxflags "${nanoem_cxxflags} ${CMAKE_CXX_FLAGS}")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} ${CMAKE_EXE_LINKER_FLAGS}")
    set(nanoem_shared_linker_flags "${nanoem_shared_linker_flags} ${CMAKE_SHARED_LINKER_FLAGS}")
  endif()
  if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "Clang")
    set(nanoem_cflags "${nanoem_cflags} -std=c++17")
    set(nanoem_cxxflags "${nanoem_cxxflags} -std=c++17")
  elseif(CMAKE_COMPILER_IS_GNUCXX)
    # -fpermissive for btSerializer
    set(nanoem_cxxflags "${nanoem_cxxflags} -std=c++17 -fpermissive")
  endif()
  if(NANOEM_ENABLE_PEDANTIC_WARNINGS)
    if("${CMAKE_CXX_COMPILER_ID}" STREQUAL "MSVC")
      set(nanoem_cflags "${nanoem_cflags} /W4 /wd4100 /wd4115 /wd4127 /wd4201 /wd4206")
    else()
      #  -Winline
      set(nanoem_cflags "${nanoem_cflags} -std=c99 -pedantic -Wall -Wbad-function-cast -Wcast-align -Wcast-qual -Wno-missing-braces -Wextra -Wno-missing-field-initializers -Wformat=2 -Wswitch-default -Wswitch-enum -Wpointer-arith -Wstrict-overflow=5 -Wstrict-prototypes -Wundef -Wnested-externs -Wshadow -Wunreachable-code -Wfloat-equal -Wstrict-aliasing=2 -Wredundant-decls -Wold-style-definition -Werror -fstrict-aliasing")
      set(nanoem_cxxflags "${nanoem_cxxflags} -pedantic -Wall -Wcast-align -Wcast-qual -Wno-missing-braces -Wextra -Wno-missing-field-initializers -Wformat=2 -Wswitch-default -Wswitch-enum -Wpointer-arith -Wstrict-overflow=5 -Wundef -Wshadow -Wunreachable-code -Wfloat-equal -Wstrict-aliasing=2 -Wredundant-decls -fstrict-aliasing")
      add_definitions(-DNANOEM_ENABLE_PEDANTIC_WARNINGS)
      if(CMAKE_COMPILER_IS_GNUCXX)
        set(nanoem_cflags "${nanoem_cflags} -Wlogical-op")
      endif()
    endif()
  elseif(MSVC)
    set(nanoem_cflags "${nanoem_cflags} /W3 /wd4100 /wd4115 /wd4127 /wd4201 /wd4206")
    set(nanoem_cxxflags "${nanoem_cxxflags} /W3 /wd4100 /wd4115 /wd4127 /wd4201 /wd4206")
  else()
    set(nanoem_cflags "${nanoem_cflags} -std=c99 -W -Wall -Wextra -Wformat -Wno-missing-field-initializers -Wformat -Wpointer-arith -Wstrict-overflow=5 -Wstrict-prototypes -Wnested-externs -Wunreachable-code -Wstrict-aliasing=2 -Wredundant-decls -Wold-style-definition -fstrict-aliasing")
    set(nanoem_cxxflags "${nanoem_cxxflags} -W -Wall -Wextra -Wformat -Wno-missing-field-initializers -Wformat -Wpointer-arith -Wstrict-overflow=5 -Wunreachable-code -Wstrict-aliasing=2 -Wredundant-decls -fstrict-aliasing")
  endif()
  set(NANOEM_LIBRARY_TYPE STATIC)
  if(NOT CMAKE_BUILD_TYPE)
    set(CMAKE_BUILD_TYPE Release CACHE STRING "" FORCE)
  endif()
  if(BUILD_SHARED_LIBS)
    set(NANOEM_LIBRARY_TYPE SHARED PARENT_SCOPE)
    add_definitions(-DNANOEM_BUILDING_DLL)
  endif()
  string(TOLOWER ${CMAKE_BUILD_TYPE} CMAKE_BUILD_TYPE_TOLOWER)
  set(${_build_type} ${CMAKE_BUILD_TYPE_TOLOWER} PARENT_SCOPE)
  if(NANOEM_ENABLE_COVERAGE AND CMAKE_COMPILER_IS_GNUCXX AND "${CMAKE_BUILD_TYPE_TOLOWER}" STREQUAL debug)
    include(CodeCoverage)
    set(nanoem_cflags "${nanoem_cflags} -g -O0 -fprofile-arcs -ftest-coverage")
    set(nanoem_exe_linker_flags "${nanoem_exe_linker_flags} -lgcov -coverage")
    setup_target_for_coverage(nanoem_coverage nanoem_test coverage)
  endif()
  if(APPLE)
    set(nanoem_cflags "${nanoem_cflags} -fobjc-arc")
    set(nanoem_cxxflags "${nanoem_cxxflags} -fobjc-arc")
  endif()
  set(CMAKE_C_FLAGS ${nanoem_cflags} PARENT_SCOPE)
  set(CMAKE_CXX_FLAGS ${nanoem_cxxflags} PARENT_SCOPE)
  set(CMAKE_EXE_LINKER_FLAGS ${nanoem_exe_linker_flags} PARENT_SCOPE)
  set(CMAKE_SHARED_LINKER_FLAGS ${nanoem_shared_linker_flags} PARENT_SCOPE)
endfunction()

function(nanoem_cmake_enable_lto target)
  if(NANOEM_ENABLE_LTO)
    set_target_properties(${target} PROPERTIES INTERPROCEDURAL_OPTIMIZATION ON)
  endif()
endfunction()

function(nanoem_cmake_find_glm)
  find_path(GLM_INCLUDE_DIR NAMES glm/glm.hpp PATHS ${PROJECT_SOURCE_DIR}/dependencies/glm NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
  mark_as_advanced(GLM_INCLUDE_DIR)
  message(STATUS "[global] glm is located at ${GLM_INCLUDE_DIR}")
endfunction()

function(nanoem_cmake_find_zlib)
  nanoem_cmake_get_install_path("zlib" ZLIB_BASE_PATH ZLIB_INSTALL_PATH_DEBUG ZLIB_INSTALL_PATH_RELEASE)
  find_library(ZLIB_LIBRARY_DEBUG NAMES zlibstaticd zlibstatic libzstatic libz.a PATH_SUFFIXES lib PATHS ${ZLIB_INSTALL_PATH_DEBUG} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
  find_library(ZLIB_LIBRARY_RELEASE NAMES zlibstatic libzstatic libz.a PATH_SUFFIXES lib PATHS ${ZLIB_INSTALL_PATH_RELEASE} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
  find_path(ZLIB_INCLUDE_DIR NAMES zlib.h PATH_SUFFIXES include PATHS ${ZLIB_INSTALL_PATH_RELEASE} NO_DEFAULT_PATH NO_CMAKE_FIND_ROOT_PATH)
  if(NOT ZLIB_LIBRARY_DEBUG OR NOT ZLIB_LIBRARY_RELEASE OR NOT ZLIB_INCLUDE_DIR)
    message(FATAL_ERROR "Cannot find zlib libraries. Did you run `cmake -P ${PROJECT_SOURCE_DIR}/scripts/build.cmake`? If you have already run it, set environment variables `NANOEM_TARGET_ARCHITECTURE` and `NANOEM_TARGET_COMPILER` properly?")
  endif()
  mark_as_advanced(ZLIB_LIBRARY_DEBUG ZLIB_LIBRARY_RELEASE ZLIB_INCLUDE_DIR)
  message(STATUS "[global] zlib is located at ${ZLIB_BASE_PATH}")
endfunction()

function(nanoem_build_test)
  # path
  get_filename_component(TEST_BASE_PATH ${CMAKE_CURRENT_BINARY_DIR}/${CMAKE_CFG_INTDIR}/test ABSOLUTE)
  get_filename_component(TEST_FIXTURES_DESTINATION ${TEST_BASE_PATH}/fixtures ABSOLUTE)
  get_filename_component(TEST_OUTPUT_DESTINATION ${TEST_BASE_PATH}/output ABSOLUTE)
  set(emapp_test_path ${CMAKE_CURRENT_SOURCE_DIR}/emapp/test)
  aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/nanoem/test NANOEM_TEST_SOURCES)
  aux_source_directory(${emapp_test_path}/common EMAPP_TEST_COMMON_SOURCES)
  aux_source_directory(${emapp_test_path}/accessory EMAPP_TEST_ACCESSORY_SOURCES)
  aux_source_directory(${emapp_test_path}/camera EMAPP_TEST_CAMERA_SOURCES)
  aux_source_directory(${emapp_test_path}/effect EMAPP_TEST_EFFECT_SOURCES)
  aux_source_directory(${emapp_test_path}/light EMAPP_TEST_LIGHT_SOURCES)
  aux_source_directory(${emapp_test_path}/misc EMAPP_TEST_MISC_SOURCES)
  aux_source_directory(${emapp_test_path}/model EMAPP_TEST_MODEL_SOURCES)
  aux_source_directory(${emapp_test_path}/motion EMAPP_TEST_MOTION_SOURCES)
  aux_source_directory(${emapp_test_path}/project EMAPP_TEST_PROJECT_SOURCES)
  if(APPLE)
    list(APPEND EMAPP_TEST_SOURCES ${emapp_test_path}/macos/document.cc)
    list(APPEND EMAPP_TEST_SOURCES ${emapp_test_path}/main.mm)
  else()
    list(APPEND EMAPP_TEST_SOURCES ${emapp_test_path}/main.cc)
  endif()
  get_property(_compile_definitions TARGET nanoem PROPERTY COMPILE_DEFINITIONS)
  add_executable(nanoem_test ${NANOEM_TEST_SOURCES}
                             ${EMAPP_TEST_COMMON_SOURCES}
                             ${EMAPP_TEST_ACCESSORY_SOURCES}
                             ${EMAPP_TEST_CAMERA_SOURCES}
                             ${EMAPP_TEST_EFFECT_SOURCES}
                             ${EMAPP_TEST_LIGHT_SOURCES}
                             ${EMAPP_TEST_MISC_SOURCES}
                             ${EMAPP_TEST_MODEL_SOURCES}
                             ${EMAPP_TEST_MOTION_SOURCES}
                             ${EMAPP_TEST_PROJECT_SOURCES}
                             ${EMAPP_TEST_SOURCES})
  target_compile_definitions(nanoem_test PRIVATE ${_compile_definitions}
                             NANOEM_TEST_FIXTURE_PATH="${TEST_FIXTURES_DESTINATION}"
                             NANOEM_TEST_OUTPUT_PATH="${TEST_OUTPUT_DESTINATION}"
                             $<$<BOOL:${WIN32}>:_CRT_SECURE_NO_WARNINGS=1>)
  # git clone https://github.com/walbourn/directxtexmedia emapp/test/directxtexmedia
  set(_directx_tex_media_directory "${emapp_test_path}/directxtexmedia")
  if(EXISTS ${_directx_tex_media_directory})
    target_compile_definitions(nanoem_test PRIVATE NANOEM_TEST_DXTEXMEDIA_PATH="${_directx_tex_media_directory}")
  endif()
  target_include_directories(nanoem_test PRIVATE ${PROJECT_SOURCE_DIR}/dependencies/catch2/single_include)
  add_custom_command(TARGET  nanoem_test POST_BUILD
                     COMMAND ${CMAKE_COMMAND} -E make_directory ${TEST_FIXTURES_DESTINATION}
                     COMMAND ${CMAKE_COMMAND} -E make_directory ${TEST_OUTPUT_DESTINATION}
                     COMMAND ${CMAKE_COMMAND} -E copy_directory ${CMAKE_CURRENT_SOURCE_DIR}/emapp/test/fixtures ${TEST_FIXTURES_DESTINATION})
  nanoem_emapp_link_executable(nanoem_test)
  set_target_properties(nanoem_test PROPERTIES WIN32_EXECUTABLE OFF)
  if(MSVC)
    target_compile_options(nanoem_test PRIVATE "/bigobj")
  elseif(APPLE)
    target_sources(nanoem_test PRIVATE ${PROJECT_SOURCE_DIR}/macos/classes/Document.mm)
    target_include_directories(nanoem_test PRIVATE ${PROJECT_SOURCE_DIR}/macos/classes)
    target_link_libraries(nanoem_test "-framework $<IF:$<BOOL:${IOS}>,UIKit,AppKit> -weak_framework AVFoundation -weak_framework Security")
  endif()
  if(NANOEM_ENABLE_STATIC_BUNDLE_PLUGIN)
    get_property(_plugins GLOBAL PROPERTY NANOEM_PROPERTY_INSTALL_PLUGINS)
    target_link_libraries(nanoem_test ${_plugins})
  endif()
endfunction()

include(${CMAKE_CURRENT_SOURCE_DIR}/cmake/GetGitRevisionDescription.cmake)

nanoem_cmake_bootstrap(PROJECT_NAME_PREFIX NANOEM_BUILD_TYPE)
git_describe(NANOEM_VERSION_GIT)

mark_as_advanced(NANOEM_MINIMAL)
if(NANOEM_ENABLE_QT)
  find_package(Qt5Core REQUIRED)
endif()

if("${CMAKE_HOST_SYSTEM_NAME}" STREQUAL "Linux" AND NOT MINGW)
  set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -pthread")
endif()
include_directories(${CMAKE_CURRENT_SOURCE_DIR})

# Sentry SDK Configuration
set(NANOEM_SENTRY_DSN "" CACHE STRING "Sentry SDK DSN")
set(NANOEM_SENTRY_ORGANIZATION "" CACHE STRING "Sentry organization name")
set(NANOEM_SENTRY_PROJECT "nanoem" CACHE STRING "Sentry project name")
set(NANOEM_SENTRY_AUTH_TOKEN "" CACHE STRING "Sentry authentication token")
set(NANOEM_GA_TRACKING_ID "" CACHE STRING "Google Analytics Tracking ID")
mark_as_advanced(NANOEM_SENTRY_DSN NANOEM_SENTRY_ORGANIZATION NANOEM_SENTRY_PROJECT NANOEM_SENTRY_AUTH_TOKEN NANOEM_GA_TRACKING_ID)

if(NANOEM_ENABLE_PLUGIN_WASM)
  if(WIN32)
    set(_plugin_wasm_filename_src "plugin_wasm.dll")
    set(_plugin_wasm_filename_dst "plugin_wasm.dll")
  elseif(APPLE)
    set(_plugin_wasm_filename_src "libplugin_wasm.dylib")
    set(_plugin_wasm_filename_dst "plugin_wasm.dylib")
  else()
    set(_plugin_wasm_filename_src "libplugin_wasm.so")
    set(_plugin_wasm_filename_dst "plugin_wasm.so")
  endif()
  set(PLUGIN_WASM_PATH "${PROJECT_SOURCE_DIR}/rust/target/release/${_plugin_wasm_filename_src}")
  set(_output_path "${CMAKE_CURRENT_BINARY_DIR}/intermediate/${_plugin_wasm_filename_dst}")
  add_custom_command(OUTPUT ${_output_path}
                     COMMAND ${CMAKE_COMMAND} ARGS -E copy_if_different ${PLUGIN_WASM_PATH} ${_output_path}
                     DEPENDS ${_output_path})
  add_custom_target(plugin_wasm_copy SOURCES ${_output_path})
  set_property(TARGET plugin_wasm_copy PROPERTY FOLDER plugins/touch)
  add_library(plugin_wasm SHARED IMPORTED GLOBAL)
  add_dependencies(plugin_wasm plugin_wasm_copy)
  set_target_properties(plugin_wasm PROPERTIES IMPORTED_LOCATION ${_output_path})
  list(APPEND _plugins plugin_wasm)
endif()

add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/docs)
add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/nanoem)
if(NOT NANOEM_MINIMAL)
  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/emapp)
  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/emapp/plugins)
  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/sandbox)
  add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/sapp)
  if(WIN32 AND NOT MINGW)
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/win32)
  elseif(APPLE)
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/macos)
  endif()
  if(NANOEM_ENABLE_QT)
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/qt)
  endif()
  if(NANOEM_ENABLE_GLFW)
    add_subdirectory(${CMAKE_CURRENT_SOURCE_DIR}/glfw)
  endif()
  if(NANOEM_ENABLE_TEST)
    enable_testing()
    include(${CMAKE_CURRENT_SOURCE_DIR}/dependencies/catch2/contrib/Catch.cmake)
    nanoem_build_test()
    catch_discover_tests(nanoem_test)
  endif()
endif()
